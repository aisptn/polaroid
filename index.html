<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="A private, client-side tool to frame and layout images into Polaroid style pairs or singles.">
    <title>Polaroid Layout Maker</title>
    <style>
        :root {
            --main-btn-size: 60px;
            --main-btn-font-size: 28px;
            --local-btn-size: 50px;
            --local-btn-font-size: 22px;
            --btn-outline-color: #808080;
            --polaroid-square-size: 445px;
            
            /* Light mode colors (default) */
            --bg-color: #f0f2f5;
            --text-color: #333;
            --container-bg: transparent;
            --toolbar-bg: rgba(240, 242, 245, 0.95);
            --placeholder-color: #606770;
            --placeholder-border: #b0b8c2;
            --separator-color: #ccc;
            --canvas-bg: #e9ecef;
            --toggle-bg: #e0e0e0;
            --toggle-knob: white;
            --logo-fill: #333;
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --container-bg: transparent;
            --toolbar-bg: rgba(26, 26, 26, 0.95);
            --placeholder-color: #a0a0a0;
            --placeholder-border: #555;
            --separator-color: #555;
            --canvas-bg: #2d2d2d;
            --toggle-bg: #333;
            --toggle-knob: #f0f0f0;
            --logo-fill: #e0e0e0;
        }

        html, body { height: 100%; margin: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
        }
        body.is-dragging { border: 4px dashed #007bff; box-sizing: border-box; }
        
        /* Gliding Dark mode toggle button */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: transparent;
            border: 2px solid var(--btn-outline-color);
            border-radius: 0; /* ZERO */
            width: 60px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 0 3px;
            transition: all 0.3s ease;
            background-color: var(--toggle-bg);
        }
        
        .toggle-knob {
            width: 24px;
            height: 24px;
            border-radius: 0; /* ZERO */
            background-color: var(--toggle-knob);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        [data-theme="dark"] .toggle-knob {
            transform: translateX(30px);
        }
        
        .theme-toggle:hover {
            border-color: var(--text-color);
        }
        
        /* Logo Styles */
        .logo-image {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            cursor: pointer;
            transition: transform 0.2s ease;
            width: 50px;
            height: 50px;
            fill: var(--logo-fill);
        }
        .logo-image:hover {
            transform: scale(1.1) rotate(-5deg);
        }
        
        .container {
            max-width: 1880px; 
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            box-sizing: border-box;
            min-height: 100%;
        }
        .container.is-empty {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        h1 { color: var(--text-color); margin-bottom: 10px; }
        p { color: var(--placeholder-color); max-width: 600px; margin: 0 auto 20px auto; line-height: 1.5; }
        
        /* Sticky Toolbar Wrapper */
        .toolbar-wrapper {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 15px 0;
            margin-top: 20px;
            background: linear-gradient(to bottom, var(--bg-color) 0%, transparent 100%);
        }
        
        .main-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-top: 0;
            background: var(--toolbar-bg);
            padding: 10px 20px;
            border-radius: 0; /* ZERO */
            width: fit-content;
            margin: 0 auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .primary-controls, .save-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        
        .save-options.hidden { display: none; }

        .button {
            display: inline-flex; align-items: center; justify-content: center;
            border-radius: 0; /* ZERO */
            cursor: pointer; font-weight: 600;
            user-select: none;
            background-color: var(--bg-color);
            border: 2px solid var(--btn-outline-color);
            color: var(--btn-outline-color);
            transition: all 0.2s ease;
            box-sizing: border-box;
        }
        @media (hover: hover) and (pointer: fine) {
            .button:hover:not(:disabled) {
                border-color: var(--text-color);
                color: var(--text-color);
                transform: translateY(-2px);
            }
        }
        .button:active { transform: scale(0.95); }
        .button:disabled {
            border-color: var(--separator-color);
            color: var(--separator-color);
            cursor: not-allowed;
            opacity: 0.5;
            transform: none;
            filter: grayscale(1);
        }
        .main-actions button, .main-actions label {
            width: var(--main-btn-size); height: var(--main-btn-size);
            font-size: var(--main-btn-font-size); padding: 0;
            border-radius: 0; /* ZERO */
        }

        .controls-row button {
            width: var(--local-btn-size); height: var(--local-btn-size);
            font-size: var(--local-btn-font-size); padding: 0;
        }
        .separator {
            background-color: var(--separator-color);
            width: 2px;
            height: 30px;
            margin: 0 5px;
        }
        .desktop-separator {
            display: none;
        }

        .save-option-wrapper.hidden { display: none; }
        .main-select {
            width: var(--main-btn-size);
            height: var(--main-btn-size);
            font-weight: 600;
            border: 2px solid var(--btn-outline-color);
            border-radius: 0; /* ZERO */
            background-color: var(--bg-color);
            color: var(--text-color);
            cursor: pointer;
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            transition: all 0.2s;
        }
        .main-select.is-square {
            padding: 12px 0 16px 0;
            box-sizing: border-box;
            font-size: 14px;
            text-align: center;
            /* Simple arrow SVG encoded */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='%23808080' viewBox='0 0 16 16'%3E%3Cpath d='m7.247 11.14-4.796-5.481c-.566-.647-.106-1.659.753-1.659h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center bottom 8px;
        }
        .main-select.wide {
            width: 90px;
            border-radius: 0; /* ZERO */
            padding: 0 10px 0 10px;
            background-position: right 10px center;
        }
        .main-select:hover:not(:disabled) {
            border-color: var(--text-color);
        }
        
        #polaroid-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 40px; 
            margin-top: 30px; 
            min-height: 200px;
            width: 100%;
            padding-bottom: 100px;
        }
        #polaroid-container:empty::before {
            content: "Drag & drop images here";
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            height: 250px;
            border: 3px dashed var(--placeholder-border);
            border-radius: 0; /* ZERO */
            color: var(--placeholder-color);
            font-size: 1.5rem;
            font-weight: 500;
            box-sizing: border-box;
            margin-top: 20px;
        }
        .polaroid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            flex: 0 1 var(--polaroid-square-size);
            max-width: 100%;
            animation: fadeIn 0.4s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-top: 100%;
            filter: drop-shadow(0 10px 15px rgba(0,0,0,0.15));
            transition: filter 0.3s;
        }
        .canvas-container:hover {
            filter: drop-shadow(0 15px 25px rgba(0,0,0,0.25));
        }
        .polaroid-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            background-color: white;
            cursor: grab;
            touch-action: none;
        }
        .polaroid-canvas:active { cursor: grabbing; }
        
        .controls { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .controls-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; align-items: center;}
        .zoom-control { 
            display: flex; align-items: center; gap: 10px; font-size: 14px; width: 100%; justify-content: center;
            background: var(--toolbar-bg); padding: 8px; border-radius: 0; /* ZERO */
        }
        .zoom-slider { width: 120px; accent-color: var(--text-color); cursor: pointer;}
        .zoom-input-wrapper { display: flex; align-items: center; font-variant-numeric: tabular-nums;}
        .zoom-value-input {
            width: 6ch; /* Updated to 6 chars width */ 
            text-align: right; border: none; border-bottom: 1px solid var(--separator-color);
            padding: 2px; font-size: 14px;
            background-color: transparent;
            color: var(--text-color);
            outline: none;
        }

        @media (min-width: 680px) {
            .main-actions {
                flex-direction: row;
                padding: 10px 30px;
            }
            .desktop-separator {
                display: block;
                height: 40px;
                margin: 0 15px;
            }
        }

        @media (max-width: 768px) {
            .logo-image {
                top: 10px;
                left: 10px;
                width: 40px;
                height: 40px;
            }
            .theme-toggle {
                top: 10px;
                right: 10px;
                width: 50px;
                height: 25px;
            }
            .container {
                padding-top: 60px;
            }
            h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <!-- Gliding Dark Mode Toggle Button -->
    <button class="theme-toggle" id="themeToggle" title="Toggle Dark Mode" aria-label="Toggle Dark Mode">
        <div class="toggle-knob">‚òÄÔ∏è</div>
    </button>
    
    <div class="container is-empty">
        <h1>Polaroid Layout Maker</h1>
        <p>Drag and drop images to start.</p>
        
        <div class="toolbar-wrapper">
            <div class="main-actions">
                <div class="primary-controls">
                    <button id="removeAllBtn" class="button" disabled title="Remove All" aria-label="Remove All">üóëÔ∏è</button>
                    <label for="imageUpload" class="button" title="Open Images" aria-label="Open Images">üìÇ</label>
                    <input type="file" id="imageUpload" multiple accept="image/*" hidden>
                    <button id="saveAllBtn" class="button" disabled title="Save All" aria-label="Save All">üì•</button>
                    <div class="separator"></div>
                    <button id="toggleFramesBtn" class="button" disabled title="Toggle All Frames" aria-label="Toggle All Frames">üñºÔ∏è</button>
                </div>
                
                <div class="separator desktop-separator"></div>
                
                <div class="save-options hidden">
                    <div id="saveModeWrapper" class="save-option-wrapper">
                         <select id="saveModeSelect" class="main-select wide" title="Layout Mode">
                            <option value="pair">2R</option>
                            <option value="individual">3R</option>
                        </select>
                    </div>
                    <div id="saveFormatWrapper" class="save-option-wrapper">
                         <select id="saveFormatSelect" class="main-select is-square" title="Save Format">
                            <option value="jpeg">JPG</option>
                            <option value="png">PNG</option>
                        </select>
                    </div>
                    <div id="jpegQualityWrapper" class="save-option-wrapper">
                        <select id="jpegQualitySelect" class="main-select is-square" title="JPEG Quality">
                            <option value="1.0">10</option>
                            <option value="0.9" selected>9</option>
                            <option value="0.8">8</option>
                            <option value="0.7">7</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div id="polaroid-container"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('debug')) initializeDebugMode();

            window.addEventListener('contextmenu', e => e.preventDefault());
            console.log(atob("YnkgYXNlcCAmIGRyaWFu"));
            const body = document.body;
            const container = document.querySelector('.container');
            const imageUpload = document.getElementById('imageUpload');
            const polaroidContainer = document.getElementById('polaroid-container');
            const saveAllBtn = document.getElementById('saveAllBtn');
            const removeAllBtn = document.getElementById('removeAllBtn');
            const toggleFramesBtn = document.getElementById('toggleFramesBtn');
            const saveModeSelect = document.getElementById('saveModeSelect');
            const saveFormatWrapper = document.getElementById('saveFormatWrapper');
            const saveFormatSelect = document.getElementById('saveFormatSelect');
            const jpegQualityWrapper = document.getElementById('jpegQualityWrapper');
            const jpegQualitySelect = document.getElementById('jpegQualitySelect');
            const themeToggle = document.getElementById('themeToggle');
            
            // Dark mode functionality
            function initDarkMode() {
                const savedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                
                if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    themeToggle.querySelector('.toggle-knob').textContent = 'üåô';
                } else {
                    document.documentElement.setAttribute('data-theme', 'light');
                    themeToggle.querySelector('.toggle-knob').textContent = '‚òÄÔ∏è';
                }
                
                themeToggle.addEventListener('click', () => {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    if (currentTheme === 'dark') {
                        document.documentElement.setAttribute('data-theme', 'light');
                        localStorage.setItem('theme', 'light');
                        themeToggle.querySelector('.toggle-knob').textContent = '‚òÄÔ∏è';
                    } else {
                        document.documentElement.setAttribute('data-theme', 'dark');
                        localStorage.setItem('theme', 'dark');
                        themeToggle.querySelector('.toggle-knob').textContent = 'üåô';
                    }
                });
            }
            initDarkMode();
            
            // Constants
            const POLAROID_EXPORT_WIDTH = 756; 
            const POLAROID_EXPORT_HEIGHT = 1120;
            const PAIR_EXPORT_WIDTH = 1600; 
            const PAIR_EXPORT_HEIGHT = 1120;
            const PORTRAIT_FRAME = { top: 90, side: 60, bottom: 182 };
            const LANDSCAPE_FRAME = { top: 90, side: 60, bottom: 166 };
            
            const DISPLAY_WIDTH_PORTRAIT = 300;
            const DISPLAY_HEIGHT_PORTRAIT = DISPLAY_WIDTH_PORTRAIT * (POLAROID_EXPORT_HEIGHT / POLAROID_EXPORT_WIDTH);
            const DISPLAY_WIDTH_LANDSCAPE = DISPLAY_HEIGHT_PORTRAIT;
            const DISPLAY_HEIGHT_LANDSCAPE = DISPLAY_WIDTH_PORTRAIT;

            const POLAROID_SQUARE_SIZE = Math.max(DISPLAY_WIDTH_LANDSCAPE, DISPLAY_HEIGHT_PORTRAIT);
            document.documentElement.style.setProperty('--polaroid-square-size', `${POLAROID_SQUARE_SIZE}px`);
            
            // Web Worker for off-thread image processing
            const workerScript = `
                // Pair Configuration
                const PAIR_POLAROID_WIDTH = 756; 
                const PAIR_POLAROID_HEIGHT = 1120; 
                const PAIR_CANVAS_WIDTH = 1600; 
                const PAIR_CANVAS_HEIGHT = 1120; 
                const PAIR_PORTRAIT_FRAME = { top: 90, side: 60, bottom: 182 }; 
                const PAIR_LANDSCAPE_FRAME = { top: 90, side: 60, bottom: 166 }; 

                // Individual Configuration
                const IND_CANVAS_WIDTH = 1120;
                const IND_CANVAS_HEIGHT = 1600;
                const IND_PORTRAIT_FRAME = { top: 128, side: 89, bottom: 260 };
                // Specific dimensions for individual landscape export
                const IND_LANDSCAPE_FRAME = { top: 133, side: 87, bottom: 246 }; 
                
                // Display constants passed for resolution scaling calculations
                const DISPLAY_WIDTH_PORTRAIT = 300; 
                const DISPLAY_HEIGHT_PORTRAIT = 444.44; // approx
                const DISPLAY_WIDTH_LANDSCAPE = 444.44; 

                function getFrameDimensions(canvasWidth, canvasHeight, isLandscape, isFrameless, mode) { 
                    if (isFrameless) return { innerBox: { x: 0, y: 0, width: canvasWidth, height: canvasHeight } }; 
                    
                    let frame;
                    let refWidth, refHeight;

                    if (mode === 'individual') {
                        frame = isLandscape ? IND_LANDSCAPE_FRAME : IND_PORTRAIT_FRAME;
                        refWidth = IND_CANVAS_WIDTH;
                        refHeight = IND_CANVAS_HEIGHT;
                    } else {
                        frame = isLandscape ? PAIR_LANDSCAPE_FRAME : PAIR_PORTRAIT_FRAME;
                        refWidth = PAIR_POLAROID_WIDTH;
                        refHeight = PAIR_POLAROID_HEIGHT;
                    }

                    if (isLandscape) { [refWidth, refHeight] = [refHeight, refWidth]; } 
                    
                    const paddingTop = canvasHeight * (frame.top / refHeight); 
                    const paddingSide = canvasWidth * (frame.side / refWidth); 
                    const paddingBottom = canvasHeight * (frame.bottom / refHeight); 
                    
                    return { innerBox: { x: Math.round(paddingSide), y: Math.round(paddingTop), width: Math.round(canvasWidth - (2 * paddingSide)), height: Math.round(canvasHeight - paddingTop - paddingBottom) } }; 
                } 
                
                function drawPolaroidOnCanvas(ctx, canvasWidth, canvasHeight, state, mode) { 
                    const { innerBox } = getFrameDimensions(canvasWidth, canvasHeight, state.isLandscape, state.isFrameless, mode); 
                    ctx.clearRect(0,0, canvasWidth, canvasHeight); 
                    if (!state.isFrameless) { ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvasWidth, canvasHeight); } 
                    ctx.save(); ctx.beginPath(); ctx.rect(innerBox.x, innerBox.y, innerBox.width, innerBox.height); ctx.clip(); 
                    
                    const displayRefWidth = state.isLandscape ? DISPLAY_WIDTH_LANDSCAPE : DISPLAY_WIDTH_PORTRAIT; 
                    
                    // Resolution scaling
                    const resolutionScaleFactor = canvasWidth / displayRefWidth; 
                    
                    const scaledWidth = state.image.width * state.scale * resolutionScaleFactor; 
                    const scaledHeight = state.image.height * state.scale * resolutionScaleFactor; 
                    const scaledPosX = state.pos.x * resolutionScaleFactor; 
                    const scaledPosY = state.pos.y * resolutionScaleFactor; 
                    const centerX = (innerBox.x + innerBox.width / 2) + scaledPosX; 
                    const centerY = (innerBox.y + innerBox.height / 2) + scaledPosY; 
                    
                    ctx.save(); ctx.translate(Math.round(centerX), Math.round(centerY)); ctx.rotate(state.imageRotation * Math.PI / 180); 
                    ctx.drawImage(state.image, Math.round(-scaledWidth / 2), Math.round(-scaledHeight / 2), Math.round(scaledWidth), Math.round(scaledHeight)); 
                    ctx.restore(); ctx.restore(); 
                } 
                
                function getFinalPolaroidCanvas(state, mode) {
                    let w, h;
                    if (mode === 'individual') {
                        w = IND_CANVAS_WIDTH; h = IND_CANVAS_HEIGHT;
                    } else {
                        w = PAIR_POLAROID_WIDTH; h = PAIR_POLAROID_HEIGHT;
                    }

                    const finalCanvas = new OffscreenCanvas(w, h); 
                    const ctx = finalCanvas.getContext('2d'); 
                    
                    if (state.isLandscape) { 
                        // Create temporary landscape canvas (swapped dims)
                        const tempLandscapeCanvas = new OffscreenCanvas(h, w); 
                        drawPolaroidOnCanvas(tempLandscapeCanvas.getContext('2d'), tempLandscapeCanvas.width, tempLandscapeCanvas.height, state, mode); 
                        
                        // Rotate onto final portrait canvas
                        ctx.save(); ctx.translate(finalCanvas.width / 2, finalCanvas.height / 2); 
                        ctx.rotate(Math.PI / 2); ctx.drawImage(tempLandscapeCanvas, -tempLandscapeCanvas.width / 2, -tempLandscapeCanvas.height / 2); ctx.restore(); 
                    } else { 
                        drawPolaroidOnCanvas(ctx, finalCanvas.width, finalCanvas.height, state, mode); 
                    } 
                    return finalCanvas; 
                } 
                
                function drawEmptyPolaroidFrame(ctx) { 
                    ctx.fillStyle = 'white'; ctx.fillRect(0, 0, PAIR_POLAROID_WIDTH, PAIR_POLAROID_HEIGHT); 
                    const innerBox = { x: PAIR_PORTRAIT_FRAME.side, y: PAIR_PORTRAIT_FRAME.top, width: PAIR_POLAROID_WIDTH - (2 * PAIR_PORTRAIT_FRAME.side), height: PAIR_POLAROID_HEIGHT - PAIR_PORTRAIT_FRAME.top - PAIR_PORTRAIT_FRAME.bottom }; 
                    ctx.fillStyle = '#e9ecef'; ctx.fillRect(innerBox.x, innerBox.y, innerBox.width, innerBox.height); 
                } 
                
                self.onmessage = async (e) => { 
                    const { polaroidStates, saveFormat, quality, filename, mode } = e.data; 
                    
                    let finalBlob;

                    if (mode === 'individual') {
                        // Individual Mode: 1120x1600
                        const canvas = getFinalPolaroidCanvas(polaroidStates[0], mode);
                        finalBlob = await canvas.convertToBlob({ type: \`image/\${saveFormat}\`, quality: saveFormat === 'jpeg' ? quality : undefined });
                    } else {
                        // Pair Mode: 1600x1120 (Side by Side)
                        const pairCanvas = new OffscreenCanvas(PAIR_CANVAS_WIDTH, PAIR_CANVAS_HEIGHT); 
                        const pairCtx = pairCanvas.getContext('2d'); 
                        pairCtx.fillStyle = '#808080'; pairCtx.fillRect(0, 0, pairCanvas.width, pairCanvas.height); 
                        
                        const finalLeftPolaroid = getFinalPolaroidCanvas(polaroidStates[0], mode); 
                        pairCtx.drawImage(finalLeftPolaroid, 0, 0); 
                        
                        if (polaroidStates[1]) { 
                            const finalRightPolaroid = getFinalPolaroidCanvas(polaroidStates[1], mode); 
                            pairCtx.drawImage(finalRightPolaroid, PAIR_CANVAS_WIDTH - PAIR_POLAROID_WIDTH, 0); 
                        } else { 
                            const emptyFrameCanvas = new OffscreenCanvas(PAIR_POLAROID_WIDTH, PAIR_POLAROID_HEIGHT); 
                            drawEmptyPolaroidFrame(emptyFrameCanvas.getContext('2d')); 
                            pairCtx.drawImage(emptyFrameCanvas, PAIR_CANVAS_WIDTH - PAIR_POLAROID_WIDTH, 0); 
                        } 
                        finalBlob = await pairCanvas.convertToBlob({ type: \`image/\${saveFormat}\`, quality: saveFormat === 'jpeg' ? quality : undefined }); 
                    }

                    self.postMessage({ blob: finalBlob, filename }); 
                };`;

            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(workerBlob);

            imageUpload.addEventListener('change', e => processFiles(e.target.files));
            saveAllBtn.addEventListener('click', saveImages);
            removeAllBtn.addEventListener('click', () => { if (confirm('Are you sure you want to remove all images?')) { polaroidContainer.innerHTML = ''; updateGlobalState(); } });
            toggleFramesBtn.addEventListener('click', () => { 
                document.querySelectorAll('.polaroid-wrapper').forEach(wrapper => { 
                    wrapper.polaroidState.isFrameless = !wrapper.polaroidState.isFrameless; 
                    wrapper.resetToCover();
                }); 
            });
            
            // Drag and Drop Zone
            body.addEventListener('dragover', (e) => { e.preventDefault(); body.classList.add('is-dragging'); });
            body.addEventListener('dragleave', (e) => { if (e.relatedTarget === null) body.classList.remove('is-dragging'); });
            body.addEventListener('drop', (e) => { e.preventDefault(); body.classList.remove('is-dragging'); processFiles(e.dataTransfer.files); });
            
            saveFormatSelect.addEventListener('change', () => {
                jpegQualityWrapper.classList.toggle('hidden', saveFormatSelect.value !== 'jpeg');
            });

            // Logo reset interaction
            document.querySelector('.logo-image').addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });

            function initializeDebugMode() {
                const debugBtn = document.createElement('button');
                debugBtn.innerText = "Debug: Add Image";
                debugBtn.style.cssText = "position:fixed;bottom:10px;left:10px;z-index:9999;border-radius:0;";
                debugBtn.onclick = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 500; canvas.height = 500;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#' + Math.floor(Math.random()*16777215).toString(16);
                    ctx.fillRect(0,0,500,500);
                    const img = new Image();
                    img.onload = () => createPolaroid(img);
                    img.src = canvas.toDataURL();
                };
                document.body.appendChild(debugBtn);
            }

            function updateGlobalState() {
                const imageCount = document.querySelectorAll('.polaroid-wrapper').length;
                const isDisabled = imageCount === 0;
                
                saveAllBtn.disabled = isDisabled;
                removeAllBtn.disabled = isDisabled;
                toggleFramesBtn.disabled = isDisabled;
                saveFormatSelect.disabled = isDisabled;
                saveModeSelect.disabled = isDisabled;
                jpegQualitySelect.disabled = isDisabled;

                const showOptions = !isDisabled;
                document.querySelector('.save-options').classList.toggle('hidden', !showOptions);
                container.classList.toggle('is-empty', isDisabled);
            }

            function processFiles(files) {
                if (!files || files.length === 0) return;
                Array.from(files).forEach(file => {
                    if (!file.type.startsWith('image/')) return;
                    try {
                        const reader = new FileReader();
                        reader.onload = e => { const img = new Image(); img.onload = () => createPolaroid(img); img.onerror = () => alert(`Failed to load the image "${file.name}".`); img.src = e.target.result; };
                        reader.onerror = () => alert(`Could not read the file: ${file.name}.`);
                        reader.readAsDataURL(file);
                    } catch (error) { alert(`An error occurred with file: ${file.name}.`); }
                });
            }

            function createPolaroid(img) {
                const isImageLandscape = img.width > img.height;
                const wrapper = document.createElement('div'); wrapper.className = 'polaroid-wrapper';
                const canvasContainer = document.createElement('div'); canvasContainer.className = 'canvas-container';
                const canvas = document.createElement('canvas'); canvas.className = 'polaroid-canvas';
                
                canvas.width = isImageLandscape ? DISPLAY_WIDTH_LANDSCAPE : DISPLAY_WIDTH_PORTRAIT;
                canvas.height = isImageLandscape ? DISPLAY_HEIGHT_LANDSCAPE : DISPLAY_HEIGHT_PORTRAIT;

                const state = { image: img, scale: 1, pos: { x: 0, y: 0 }, isLandscape: isImageLandscape, isFrameless: false, imageRotation: 0, fitScale: 1, fillScale: 1 };
                canvas.polaroidState = state;
                
                const controls = document.createElement('div'); controls.className = 'controls';
                const controlsRow = document.createElement('div'); controlsRow.className = 'controls-row';
                
                // Zoom UI
                const zoomControl = document.createElement('div'); zoomControl.className = 'zoom-control';
                const zoomSlider = document.createElement('input'); 
                const zoomValueInput = document.createElement('input');
                const zoomInputWrapper = document.createElement('div'); zoomInputWrapper.className = 'zoom-input-wrapper';
                
                zoomSlider.type = 'range'; zoomSlider.className = 'zoom-slider'; zoomSlider.step = 0.01; zoomSlider.ariaLabel = "Zoom Level";
                zoomValueInput.type = 'number'; zoomValueInput.className = 'zoom-value-input'; zoomValueInput.min = 100;
                
                zoomControl.innerHTML = `<span>üîç</span>`; zoomControl.appendChild(zoomSlider);
                zoomInputWrapper.appendChild(zoomValueInput); zoomInputWrapper.insertAdjacentHTML('beforeend', `<span>%</span>`);
                zoomControl.appendChild(zoomInputWrapper);

                // Buttons
                const removeBtn = document.createElement('button'); removeBtn.className = 'button'; removeBtn.textContent = 'üóëÔ∏è'; removeBtn.title = 'Remove';
                const rotateImageBtn = document.createElement('button'); rotateImageBtn.className = 'button'; rotateImageBtn.textContent = 'üîÑ'; rotateImageBtn.title = 'Rotate Image';
                const frameBtn = document.createElement('button'); frameBtn.className = 'button'; frameBtn.textContent = 'üñºÔ∏è'; frameBtn.title = 'Toggle Frame';
                const resetZoomBtn = document.createElement('button'); resetZoomBtn.className = 'button'; resetZoomBtn.textContent = 'üîç'; resetZoomBtn.title = 'Reset Zoom';
                const toggleFrameOrientationBtn = document.createElement('button'); toggleFrameOrientationBtn.className = 'button';

                const separator1 = document.createElement('div'); separator1.className = 'separator';
                const separator2 = document.createElement('div'); separator2.className = 'separator';
                
                controlsRow.appendChild(removeBtn);
                controlsRow.appendChild(separator1);
                controlsRow.appendChild(frameBtn);
                controlsRow.appendChild(toggleFrameOrientationBtn);
                controlsRow.appendChild(separator2);
                controlsRow.appendChild(rotateImageBtn);
                controlsRow.appendChild(resetZoomBtn);
                
                controls.appendChild(zoomControl); controls.appendChild(controlsRow);
                canvasContainer.appendChild(canvas);
                wrapper.appendChild(canvasContainer);
                wrapper.appendChild(controls);

                polaroidContainer.appendChild(wrapper);
                updateGlobalState();
                
                const ctx = canvas.getContext('2d');
                const update = () => { applySmartScaling(); clampPosition(); redraw(); };
                wrapper.update = update; wrapper.polaroidState = state;
                
                // Exposed helper to reset zoom when frames change
                wrapper.resetToCover = () => {
                    applySmartScaling();
                    state.scale = state.fillScale;
                    state.pos = { x: 0, y: 0 };
                    clampPosition();
                    redraw();
                };
                
                function updateOrientationButton() {
                    if (state.isLandscape) {
                        toggleFrameOrientationBtn.textContent = '‚ÜïÔ∏è'; toggleFrameOrientationBtn.title = 'Set Portrait Frame';
                    } else {
                        toggleFrameOrientationBtn.textContent = '‚ÜîÔ∏è'; toggleFrameOrientationBtn.title = 'Set Landscape Frame';
                    }
                }

                function updateZoomDisplay() {
                    const percentage = Math.round((state.scale / state.fitScale) * 100);
                    zoomValueInput.value = percentage;
                    zoomSlider.value = state.scale;
                }

                function applySmartScaling() {
                    const MAX_ZOOM_MULTIPLIER = 10;
                    const { innerBox } = getFrameDimensions(canvas.width, canvas.height, state.isLandscape, state.isFrameless);
                    let effectiveImgWidth = img.width;
                    let effectiveImgHeight = img.height;
                    if (state.imageRotation % 180 !== 0) { [effectiveImgWidth, effectiveImgHeight] = [effectiveImgHeight, effectiveImgWidth]; }
                    const hRatio = innerBox.width / effectiveImgWidth; const vRatio = innerBox.height / effectiveImgHeight;
                    state.fitScale = Math.min(hRatio, vRatio);
                    state.fillScale = Math.max(hRatio, vRatio);
                    // Only reset scale if currently invalid or 1
                    if(state.scale === 1) state.scale = state.fillScale;
                    zoomSlider.min = state.fitScale;
                    zoomSlider.max = state.fitScale * MAX_ZOOM_MULTIPLIER;
                    updateZoomDisplay();
                }

                function clampPosition() {
                    const { innerBox } = getFrameDimensions(canvas.width, canvas.height, state.isLandscape, state.isFrameless);
                    let effectiveImgWidth = state.image.width;
                    let effectiveImgHeight = state.image.height;
                    if (state.imageRotation % 180 !== 0) { [effectiveImgWidth, effectiveImgHeight] = [effectiveImgHeight, effectiveImgWidth]; }
                    const scaledWidth = effectiveImgWidth * state.scale; const scaledHeight = effectiveImgHeight * state.scale;
                    const overhangX = scaledWidth - innerBox.width; const maxX = Math.max(0, overhangX / 2); state.pos.x = Math.max(-maxX, Math.min(maxX, state.pos.x));
                    const overhangY = scaledHeight - innerBox.height; const maxY = Math.max(0, overhangY / 2); state.pos.y = Math.max(-maxY, Math.min(maxY, state.pos.y));
                }

                applySmartScaling(); 
                redraw();
                updateOrientationButton();

                function redraw() { requestAnimationFrame(() => { drawPolaroidOnCanvas(ctx, canvas.width, canvas.height, state); if (document.activeElement !== zoomSlider && document.activeElement !== zoomValueInput) { updateZoomDisplay(); } }); }
                
                removeBtn.onclick = () => { wrapper.style.opacity = '0'; setTimeout(() => { wrapper.remove(); updateGlobalState(); }, 300); };
                
                toggleFrameOrientationBtn.onclick = () => {
                    state.isLandscape = !state.isLandscape;
                    state.pos = { x: 0, y: 0 };
                    if (state.isLandscape) {
                        canvas.width = DISPLAY_WIDTH_LANDSCAPE;
                        canvas.height = DISPLAY_HEIGHT_LANDSCAPE;
                    } else {
                        canvas.width = DISPLAY_WIDTH_PORTRAIT;
                        canvas.height = DISPLAY_HEIGHT_PORTRAIT;
                    }
                    wrapper.resetToCover();
                    updateOrientationButton();
                };

                rotateImageBtn.onclick = () => { state.imageRotation = (state.imageRotation + 90) % 360; state.pos = { x: 0, y: 0 }; update(); };
                frameBtn.onclick = () => { 
                    state.isFrameless = !state.isFrameless; 
                    wrapper.resetToCover(); 
                };
                resetZoomBtn.onclick = () => { state.scale = state.fillScale; state.pos = { x: 0, y: 0 }; clampPosition(); redraw(); };
                
                zoomSlider.addEventListener('input', e => { state.scale = parseFloat(e.target.value); clampPosition(); redraw(); });
                zoomValueInput.addEventListener('change', e => { const percentage = parseFloat(e.target.value); if (isNaN(percentage)) return; const newScale = (percentage / 100) * state.fitScale; state.scale = Math.max(parseFloat(zoomSlider.min), Math.min(parseFloat(zoomSlider.max), newScale)); clampPosition(); redraw(); });
                
                // Pan and Pinch Logic
                let interactionState = { dragStart: { x: 0, y: 0 }, isPinching: false, initialPinchDistance: 0, initialScale: 1 };
                function getDistance(p1, p2) { return Math.sqrt(Math.pow(p2.clientX - p1.clientX, 2) + Math.pow(p2.clientY - p1.clientY, 2)); }
                function handleMouseMove(e) { state.pos.x = e.clientX - interactionState.dragStart.x; state.pos.y = e.clientY - interactionState.dragStart.y; clampPosition(); redraw(); }
                
                canvas.addEventListener('mousedown', e => { 
                    interactionState.dragStart.x = e.clientX - state.pos.x; interactionState.dragStart.y = e.clientY - state.pos.y; 
                    canvas.addEventListener('mousemove', handleMouseMove); canvas.style.cursor = 'grabbing'; 
                });
                window.addEventListener('mouseup', () => { canvas.removeEventListener('mousemove', handleMouseMove); canvas.style.cursor = 'grab'; });
                
                canvas.addEventListener('touchstart', e => { 
                    const t = e.touches; 
                    if (t.length === 1) { interactionState.dragStart.x = t[0].clientX - state.pos.x; interactionState.dragStart.y = t[0].clientY - state.pos.y; } 
                    else if (t.length === 2) { e.preventDefault(); interactionState.isPinching = true; interactionState.initialPinchDistance = getDistance(t[0], t[1]); interactionState.initialScale = state.scale; } 
                }, { passive: false });
                
                canvas.addEventListener('touchmove', e => { 
                    const t = e.touches; 
                    if (t.length === 1 && !interactionState.isPinching) { e.preventDefault(); state.pos.x = t[0].clientX - interactionState.dragStart.x; state.pos.y = t[0].clientY - interactionState.dragStart.y; } 
                    else if (t.length === 2 && interactionState.isPinching) { e.preventDefault(); const r = getDistance(t[0], t[1]) / interactionState.initialPinchDistance; state.scale = Math.max(parseFloat(zoomSlider.min), Math.min(parseFloat(zoomSlider.max), interactionState.initialScale * r)); } 
                    clampPosition(); redraw(); 
                }, { passive: false });
                
                canvas.addEventListener('touchend', e => { if (e.touches.length < 2) interactionState.isPinching = false; if (e.touches.length === 1) { interactionState.dragStart.x = e.touches[0].clientX - state.pos.x; interactionState.dragStart.y = e.touches[0].clientY - state.pos.y; } });
            }

            function getFrameDimensions(canvasWidth, canvasHeight, isLandscape, isFrameless) {
                if (isFrameless) return { innerBox: { x: 0, y: 0, width: canvasWidth, height: canvasHeight } }; 
                const frame = isLandscape ? LANDSCAPE_FRAME : PORTRAIT_FRAME;
                let refWidth = POLAROID_EXPORT_WIDTH, refHeight = POLAROID_EXPORT_HEIGHT;
                if (isLandscape) { [refWidth, refHeight] = [refHeight, refWidth]; }
                const paddingTop = canvasHeight * (frame.top / refHeight);
                const paddingSide = canvasWidth * (frame.side / refWidth);
                const paddingBottom = canvasHeight * (frame.bottom / refHeight);
                return { innerBox: { x: Math.round(paddingSide), y: Math.round(paddingTop), width: Math.round(canvasWidth - (2 * paddingSide)), height: Math.round(canvasHeight - paddingTop - paddingBottom) }};
            }

            function drawPolaroidOnCanvas(ctx, canvasWidth, canvasHeight, state) {
                const { innerBox } = getFrameDimensions(canvasWidth, canvasHeight, state.isLandscape, state.isFrameless);
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                if (!state.isFrameless) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                }
                ctx.save();
                ctx.beginPath();
                ctx.rect(innerBox.x, innerBox.y, innerBox.width, innerBox.height);
                ctx.clip();
                const scaledWidth = state.image.width * state.scale;
                const scaledHeight = state.image.height * state.scale;
                const centerX = (innerBox.x + innerBox.width / 2) + state.pos.x;
                const centerY = (innerBox.y + innerBox.height / 2) + state.pos.y;
                ctx.save();
                ctx.translate(Math.round(centerX), Math.round(centerY));
                ctx.rotate(state.imageRotation * Math.PI / 180);
                ctx.drawImage(state.image, Math.round(-scaledWidth / 2), Math.round(-scaledHeight / 2), Math.round(scaledWidth), Math.round(scaledHeight));
                ctx.restore();
                ctx.restore();
            }

            function generateTimestampFilename(fileNumber, totalFiles) {
                const now = new Date();
                const YYYY = now.getFullYear(); const MM = String(now.getMonth() + 1).padStart(2, '0'); const DD = String(now.getDate()).padStart(2, '0');
                const hh = String(now.getHours()).padStart(2, '0'); const mm = String(now.getMinutes()).padStart(2, '0'); const ss = String(now.getSeconds()).padStart(2, '0'); 
                const paddedNumber = String(fileNumber).padStart(String(totalFiles).length > 0 ? String(totalFiles).length : 1, '0');
                return `${YYYY}-${MM}-${DD}_${hh}-${mm}-${ss}_${paddedNumber}`;
            }

            function updateSaveButtonProgress(current, total) {
                saveAllBtn.innerHTML = `${current} / ${total}`;
            }

            async function saveImages() {
                if(typeof OffscreenCanvas === 'undefined') {
                    alert("Your browser does not support the technology required to export these images (OffscreenCanvas). Please try using Chrome, Edge, or a newer version of Safari.");
                    return;
                }

                const canvases = Array.from(document.querySelectorAll('.polaroid-canvas'));
                if (canvases.length === 0) return;
                const originalText = saveAllBtn.innerHTML;
                saveAllBtn.disabled = true;
                
                const mode = saveModeSelect.value; // 'pair' or 'individual'
                const jobQueue = [];
                
                if (mode === 'individual') {
                    for (let i = 0; i < canvases.length; i++) {
                        jobQueue.push({ leftIndex: i, rightIndex: null });
                    }
                } else {
                    for (let i = 0; i < canvases.length; i += 2) {
                        jobQueue.push({ leftIndex: i, rightIndex: i + 1 });
                    }
                }

                const numFiles = jobQueue.length;
                let filesProcessed = 0;
                
                const worker = new Worker(workerUrl);
                
                let polaroidDirHandle;
                try {
                    if ('showDirectoryPicker' in window) {
                        polaroidDirHandle = await window.showDirectoryPicker();
                        polaroidDirHandle = await polaroidDirHandle.getDirectoryHandle('polaroid', { create: true });
                    }
                } catch (error) { console.log('File System Access API skipped or failed.'); }

                const processNextJobInQueue = async () => {
                    if (jobQueue.length === 0) {
                        saveAllBtn.innerHTML = originalText;
                        updateGlobalState();
                        worker.terminate();
                        if (polaroidDirHandle) alert(`Saved to "polaroid" folder!`);
                        return;
                    }
                    const job = jobQueue.shift();
                    const fileIndex = filesProcessed + 1;
                    const transferList = [];
                    const polaroidStates = [];
                    
                    const leftCanvas = canvases[job.leftIndex];
                    if (leftCanvas) {
                        const bmp = await createImageBitmap(leftCanvas.polaroidState.image);
                        transferList.push(bmp);
                        polaroidStates.push({ ...leftCanvas.polaroidState, image: bmp });
                    }
                    
                    if (mode === 'pair') {
                        const rightCanvas = canvases[job.rightIndex];
                        if (rightCanvas) {
                            const bmp = await createImageBitmap(rightCanvas.polaroidState.image);
                            transferList.push(bmp);
                            polaroidStates.push({ ...rightCanvas.polaroidState, image: bmp });
                        }
                    }
                    
                    const saveFormat = saveFormatSelect.value;
                    const quality = parseFloat(jpegQualitySelect.value);
                    const fileExtension = saveFormat === 'jpeg' ? '.jpeg' : '.png';
                    const filename = generateTimestampFilename(fileIndex, numFiles) + fileExtension;
                    
                    worker.postMessage({ polaroidStates, saveFormat, quality, filename, mode }, transferList);
                };
                
                worker.onmessage = async (e) => {
                    const { blob, filename } = e.data;
                    try {
                        if (polaroidDirHandle) {
                            const fileHandle = await polaroidDirHandle.getFileHandle(filename, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                        } else {
                            const link = document.createElement('a');
                            const url = URL.createObjectURL(blob);
                            link.href = url;
                            link.download = filename;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }
                    } catch (error) { console.error(error); }
                    
                    filesProcessed++;
                    updateSaveButtonProgress(filesProcessed, numFiles);
                    processNextJobInQueue();
                };
                
                updateSaveButtonProgress(0, numFiles);
                processNextJobInQueue();
            }
            updateGlobalState();
        });
    </script>
</body>
</html>
