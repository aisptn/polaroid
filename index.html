<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description"
        content="A private, client-side tool to frame and layout images into Polaroid style pairs or singles.">
    <title>Polaroid Layout Maker</title>
    <style>
        :root {
            font-size: 16px;

            /* Light mode colors (default) */
            --bg-color: #ffffff;
            --text-color: #000000;
            --muted-color: #666666;
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --muted-color: #999999;
        }

        * {
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
        }

        html,
        body {
            height: 100%;
            margin: 0;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.2s, color 0.2s;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            line-height: 1.6;
        }

        a {
            color: var(--text-color);
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        /* Dark mode toggle */
        .theme-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            background: transparent;
            border: 1px solid var(--text-color);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            color: var(--text-color);
            text-transform: uppercase;
            letter-spacing: 0.0625rem;
        }

        .theme-toggle:hover {
            background-color: var(--text-color);
            color: var(--bg-color);
        }

        .container {
            max-width: 75rem;
            margin: 0 auto;
            padding: 1.25rem;
            text-align: center;
            min-height: 100%;
        }

        .container.is-empty {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        h1 {
            font-size: 1rem;
            font-weight: bold;
            letter-spacing: 0.0625rem;
            margin: 0 0 0.5rem 0;
            text-transform: uppercase;
        }

        p {
            color: var(--muted-color);
            max-width: 31.25rem;
            margin: 0 auto 1rem auto;
            font-size: 0.75rem;
            letter-spacing: 0.03125rem;
        }

        /* Toolbar */
        .toolbar-wrapper {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 0.75rem 0;
            margin-top: 1rem;
            background: var(--bg-color);
            border-bottom: 1px solid var(--muted-color);
        }

        .main-actions {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 0 auto;
            width: fit-content;
            padding: 0;
        }

        .primary-controls,
        .global-controls,
        .save-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .save-options {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
        }

        .save-options.hidden {
            display: none;
        }

        .button,
        .toggle-button,
        .main-select {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 2rem;
            padding: 0.25rem 0.75rem;
            font-size: 0.6875rem;
            text-transform: uppercase;
            letter-spacing: 0.03125rem;
            cursor: pointer;
            background: transparent;
            border: 1px solid var(--text-color);
            color: var(--text-color);
            transition: all 0.15s;
            white-space: nowrap;
        }

        @media (hover: hover) and (pointer: fine) {

            .button:hover:not(:disabled),
            .toggle-button:hover:not(:disabled),
            .main-select:hover:not(:disabled) {
                background-color: var(--text-color);
                color: var(--bg-color);
            }
        }

        .button:active,
        .toggle-button:active {
            opacity: 0.6;
        }

        .toggle-button.active {
            background-color: var(--text-color);
            color: var(--bg-color);
        }

        .toggle-group {
            display: flex;
            border: 1px solid var(--text-color);
            background: transparent;
        }

        .toggle-button {
            border: none;
            border-right: 1px solid var(--text-color);
            flex: 1;
            color: var(--muted-color);
        }

        .toggle-button:last-child {
            border-right: none;
        }

        .hidden {
            display: none;
        }

        .separator {
            width: 1px;
            height: 1.25rem;
            background-color: var(--muted-color);
            margin: 0 0.25rem;
        }

        .save-option-wrapper.hidden {
            display: none;
        }

        .main-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 1.25rem;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 16 16'%3E%3Cpath fill='%23000' d='M7.247 11.14l-4.796-5.481c-.566-.647-.106-1.659.753-1.659h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.25rem center;
        }

        [data-theme="dark"] .main-select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 16 16'%3E%3Cpath fill='%23fff' d='M7.247 11.14l-4.796-5.481c-.566-.647-.106-1.659.753-1.659h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
        }

        .main-select:hover:not(:disabled) {
            background-color: var(--text-color);
            color: var(--bg-color);
        }

        #polaroid-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.875rem;
            margin-top: 1.5rem;
            min-height: 12.5rem;
            width: 100%;
            padding-bottom: 5rem;
        }

        #polaroid-container:empty::before {
            content: "drag & drop images";
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 25rem;
            height: 12.5rem;
            border: 1px dashed var(--text-color);
            color: var(--muted-color);
            font-size: var(--font-size-base);
            letter-spacing: var(--space-xs);
            margin-top: var(--space-lg);
        }

        body.is-dragging #polaroid-container:empty::before {
            border-style: solid;
        }

        .polaroid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            flex: 0 1 27.8125rem;
            max-width: 100%;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-top: 100%;
        }

        .polaroid-canvas {
            border: 1px solid var(--muted-color);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            background-color: white;
            cursor: grab;
            touch-action: none;
        }

        .polaroid-canvas:active {
            cursor: grabbing;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
        }

        .controls-row {
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: stretch;
            width: 100%;
            min-height: 1.75rem;
        }

        .zoom-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.6875rem;
            flex: 1;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--text-color);
            text-transform: uppercase;
            letter-spacing: 0.03125rem;
        }

        .zoom-slider {
            flex: 1;
            min-width: 3rem;
            cursor: pointer;
            accent-color: var(--text-color);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            height: 0.125rem;
            background: var(--text-color);
            outline: none;
            border: none;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0.75rem;
            height: 0.75rem;
            border: 1px solid var(--text-color);
            background: var(--bg-color);
            cursor: pointer;
        }

        .zoom-slider::-moz-range-thumb {
            width: 0.75rem;
            height: 0.75rem;
            border: 1px solid var(--text-color);
            background: var(--bg-color);
            cursor: pointer;
        }

        .zoom-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.125rem;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
        }

        .zoom-value-input {
            width: 7ch;
            text-align: right;
            border: none;
            border-bottom: 1px solid var(--text-color);
            padding: 0.125rem 0.125rem;
            font-size: 0.6875rem;
            background-color: transparent;
            color: var(--text-color);
        }

        @media (max-width: 48rem) {
            .container {
                padding-top: 3.125rem;
            }

            h1 {
                font-size: 0.875rem;
            }
        }
    </style>
</head>

<body>
    <!-- Dark Mode Toggle -->
    <button class="theme-toggle" id="themeToggle" title="Toggle Dark Mode" aria-label="Toggle Dark Mode">
        [ DARK ]
    </button>


    <div class="container is-empty">
        <h1>Polaroid Maker</h1>
        <p>a minimal tool for framing images</p>
        <p><a href="./legacy">click here for the legacy version</a></p>

        <div class="toolbar-wrapper">
            <div class="main-actions">
                <div class="primary-controls">
                    <button id="removeAllBtn" class="button" disabled title="Remove All">clear</button>
                    <label for="imageUpload" class="button" title="Open Images">open</label>
                    <input type="file" id="imageUpload" multiple accept="image/*" hidden>
                </div>

                <div class="global-controls">
                    <div id="globalFrameToggle" class="toggle-group">
                        <button class="toggle-button active" data-value="on">frame on</button>
                        <button class="toggle-button" data-value="off">frame off</button>
                    </div>
                </div>

                <div class="save-controls">
                    <div class="save-options hidden">
                        <div id="saveModeWrapper" class="save-option-wrapper">
                            <select id="saveModeSelect" class="main-select" title="Layout Mode">
                                <option value="pair">2r</option>
                                <option value="individual">3r</option>
                            </select>
                        </div>
                        <div id="saveFormatWrapper" class="save-option-wrapper">
                            <select id="saveFormatSelect" class="main-select" title="Save Format">
                                <option value="jpeg">jpg</option>
                                <option value="png">png</option>
                            </select>
                        </div>
                        <div id="jpegQualityWrapper" class="save-option-wrapper">
                            <select id="jpegQualitySelect" class="main-select" title="JPEG Quality">
                                <option value="1.0">100%</option>
                                <option value="0.9" selected>90%</option>
                                <option value="0.8">80%</option>
                                <option value="0.7">70%</option>
                            </select>
                        </div>
                    </div>
                    <button id="saveAllBtn" class="button" disabled title="Save All">save</button>
                </div>
            </div>
        </div>

        <div id="polaroid-container"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('debug')) initializeDebugMode();

            window.addEventListener('contextmenu', e => e.preventDefault());
            console.log(atob("YnkgYXNlcCAmIGRyaWFu"));
            const body = document.body;
            const container = document.querySelector('.container');
            const imageUpload = document.getElementById('imageUpload');
            const polaroidContainer = document.getElementById('polaroid-container');
            const saveAllBtn = document.getElementById('saveAllBtn');
            const removeAllBtn = document.getElementById('removeAllBtn');
            const globalFrameToggle = document.getElementById('globalFrameToggle');
            const saveModeSelect = document.getElementById('saveModeSelect');
            const saveFormatWrapper = document.getElementById('saveFormatWrapper');
            const saveFormatSelect = document.getElementById('saveFormatSelect');
            const jpegQualityWrapper = document.getElementById('jpegQualityWrapper');
            const jpegQualitySelect = document.getElementById('jpegQualitySelect');
            const themeToggle = document.getElementById('themeToggle');

            // Dark mode functionality
            function initDarkMode() {
                const savedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

                if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    themeToggle.textContent = '[ LIGHT ]';
                } else {
                    document.documentElement.setAttribute('data-theme', 'light');
                    themeToggle.textContent = '[ DARK ]';
                }

                themeToggle.addEventListener('click', () => {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    if (currentTheme === 'dark') {
                        document.documentElement.setAttribute('data-theme', 'light');
                        localStorage.setItem('theme', 'light');
                        themeToggle.textContent = '[ DARK ]';
                    } else {
                        document.documentElement.setAttribute('data-theme', 'dark');
                        localStorage.setItem('theme', 'dark');
                        themeToggle.textContent = '[ LIGHT ]';
                    }
                });
            }
            initDarkMode();

            // Constants
            const POLAROID_EXPORT_WIDTH = 756;
            const POLAROID_EXPORT_HEIGHT = 1120;
            const PAIR_EXPORT_WIDTH = 1600;
            const PAIR_EXPORT_HEIGHT = 1120;
            const PORTRAIT_FRAME = { top: 90, side: 60, bottom: 182 };
            const LANDSCAPE_FRAME = { top: 90, side: 60, bottom: 166 };

            const DISPLAY_WIDTH_PORTRAIT = 300;
            const DISPLAY_HEIGHT_PORTRAIT = DISPLAY_WIDTH_PORTRAIT * (POLAROID_EXPORT_HEIGHT / POLAROID_EXPORT_WIDTH);
            const DISPLAY_WIDTH_LANDSCAPE = DISPLAY_HEIGHT_PORTRAIT;
            const DISPLAY_HEIGHT_LANDSCAPE = DISPLAY_WIDTH_PORTRAIT;

            const POLAROID_SQUARE_SIZE = Math.max(DISPLAY_WIDTH_LANDSCAPE, DISPLAY_HEIGHT_PORTRAIT);
            document.documentElement.style.setProperty('--polaroid-square-size', `${POLAROID_SQUARE_SIZE}px`);

            // Web Worker for off-thread image processing
            const workerScript = `
                // Pair Configuration
                const PAIR_POLAROID_WIDTH = 756; 
                const PAIR_POLAROID_HEIGHT = 1120; 
                const PAIR_CANVAS_WIDTH = 1600; 
                const PAIR_CANVAS_HEIGHT = 1120; 
                const PAIR_PORTRAIT_FRAME = { top: 90, side: 60, bottom: 182 }; 
                const PAIR_LANDSCAPE_FRAME = { top: 90, side: 60, bottom: 166 }; 

                // Individual Configuration
                const IND_CANVAS_WIDTH = 1120;
                const IND_CANVAS_HEIGHT = 1600;
                const IND_PORTRAIT_FRAME = { top: 128, side: 89, bottom: 260 };
                // Specific dimensions for individual landscape export
                const IND_LANDSCAPE_FRAME = { top: 133, side: 87, bottom: 246 }; 
                
                // Display constants passed for resolution scaling calculations
                const DISPLAY_WIDTH_PORTRAIT = 300; 
                const DISPLAY_HEIGHT_PORTRAIT = 444.44; // approx
                const DISPLAY_WIDTH_LANDSCAPE = 444.44; 

                function getFrameDimensions(canvasWidth, canvasHeight, isLandscape, isFrameless, mode) { 
                    if (isFrameless) return { innerBox: { x: 0, y: 0, width: canvasWidth, height: canvasHeight } }; 
                    
                    let frame;
                    let refWidth, refHeight;

                    if (mode === 'individual') {
                        frame = isLandscape ? IND_LANDSCAPE_FRAME : IND_PORTRAIT_FRAME;
                        refWidth = IND_CANVAS_WIDTH;
                        refHeight = IND_CANVAS_HEIGHT;
                    } else {
                        frame = isLandscape ? PAIR_LANDSCAPE_FRAME : PAIR_PORTRAIT_FRAME;
                        refWidth = PAIR_POLAROID_WIDTH;
                        refHeight = PAIR_POLAROID_HEIGHT;
                    }

                    if (isLandscape) { [refWidth, refHeight] = [refHeight, refWidth]; } 
                    
                    const paddingTop = canvasHeight * (frame.top / refHeight); 
                    const paddingSide = canvasWidth * (frame.side / refWidth); 
                    const paddingBottom = canvasHeight * (frame.bottom / refHeight); 
                    
                    return { innerBox: { x: Math.round(paddingSide), y: Math.round(paddingTop), width: Math.round(canvasWidth - (2 * paddingSide)), height: Math.round(canvasHeight - paddingTop - paddingBottom) } }; 
                } 
                
                function drawPolaroidOnCanvas(ctx, canvasWidth, canvasHeight, state, mode) { 
                    const { innerBox } = getFrameDimensions(canvasWidth, canvasHeight, state.isLandscape, state.isFrameless, mode); 
                    ctx.clearRect(0,0, canvasWidth, canvasHeight); 
                    if (!state.isFrameless) { ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvasWidth, canvasHeight); } 
                    ctx.save(); ctx.beginPath(); ctx.rect(innerBox.x, innerBox.y, innerBox.width, innerBox.height); ctx.clip(); 
                    
                    const displayRefWidth = state.isLandscape ? DISPLAY_WIDTH_LANDSCAPE : DISPLAY_WIDTH_PORTRAIT; 
                    
                    // Resolution scaling
                    const resolutionScaleFactor = canvasWidth / displayRefWidth; 
                    
                    const scaledWidth = state.image.width * state.scale * resolutionScaleFactor; 
                    const scaledHeight = state.image.height * state.scale * resolutionScaleFactor; 
                    const scaledPosX = state.pos.x * resolutionScaleFactor; 
                    const scaledPosY = state.pos.y * resolutionScaleFactor; 
                    const centerX = (innerBox.x + innerBox.width / 2) + scaledPosX; 
                    const centerY = (innerBox.y + innerBox.height / 2) + scaledPosY; 
                    
                    ctx.save(); ctx.translate(Math.round(centerX), Math.round(centerY)); ctx.rotate(state.imageRotation * Math.PI / 180); 
                    ctx.drawImage(state.image, Math.round(-scaledWidth / 2), Math.round(-scaledHeight / 2), Math.round(scaledWidth), Math.round(scaledHeight)); 
                    ctx.restore(); ctx.restore(); 
                } 
                
                function getFinalPolaroidCanvas(state, mode) {
                    let w, h;
                    if (mode === 'individual') {
                        w = IND_CANVAS_WIDTH; h = IND_CANVAS_HEIGHT;
                    } else {
                        w = PAIR_POLAROID_WIDTH; h = PAIR_POLAROID_HEIGHT;
                    }

                    const finalCanvas = new OffscreenCanvas(w, h); 
                    const ctx = finalCanvas.getContext('2d'); 
                    
                    if (state.isLandscape) { 
                        // Create temporary landscape canvas (swapped dims)
                        const tempLandscapeCanvas = new OffscreenCanvas(h, w); 
                        drawPolaroidOnCanvas(tempLandscapeCanvas.getContext('2d'), tempLandscapeCanvas.width, tempLandscapeCanvas.height, state, mode); 
                        
                        // Rotate onto final portrait canvas
                        ctx.save(); ctx.translate(finalCanvas.width / 2, finalCanvas.height / 2); 
                        ctx.rotate(Math.PI / 2); ctx.drawImage(tempLandscapeCanvas, -tempLandscapeCanvas.width / 2, -tempLandscapeCanvas.height / 2); ctx.restore(); 
                    } else { 
                        drawPolaroidOnCanvas(ctx, finalCanvas.width, finalCanvas.height, state, mode); 
                    } 
                    return finalCanvas; 
                } 
                
                function drawEmptyPolaroidFrame(ctx) { 
                    ctx.fillStyle = 'white'; ctx.fillRect(0, 0, PAIR_POLAROID_WIDTH, PAIR_POLAROID_HEIGHT); 
                    const innerBox = { x: PAIR_PORTRAIT_FRAME.side, y: PAIR_PORTRAIT_FRAME.top, width: PAIR_POLAROID_WIDTH - (2 * PAIR_PORTRAIT_FRAME.side), height: PAIR_POLAROID_HEIGHT - PAIR_PORTRAIT_FRAME.top - PAIR_PORTRAIT_FRAME.bottom }; 
                    ctx.fillStyle = '#e9ecef'; ctx.fillRect(innerBox.x, innerBox.y, innerBox.width, innerBox.height); 
                } 
                
                self.onmessage = async (e) => { 
                    const { polaroidStates, saveFormat, quality, filename, mode } = e.data; 
                    
                    let finalBlob;

                    if (mode === 'individual') {
                        // Individual Mode: 1120x1600
                        const canvas = getFinalPolaroidCanvas(polaroidStates[0], mode);
                        finalBlob = await canvas.convertToBlob({ type: \`image/\${saveFormat}\`, quality: saveFormat === 'jpeg' ? quality : undefined });
                    } else {
                        // Pair Mode: 1600x1120 (Side by Side)
                        const pairCanvas = new OffscreenCanvas(PAIR_CANVAS_WIDTH, PAIR_CANVAS_HEIGHT); 
                        const pairCtx = pairCanvas.getContext('2d'); 
                        pairCtx.fillStyle = '#808080'; pairCtx.fillRect(0, 0, pairCanvas.width, pairCanvas.height); 
                        
                        const finalLeftPolaroid = getFinalPolaroidCanvas(polaroidStates[0], mode); 
                        pairCtx.drawImage(finalLeftPolaroid, 0, 0); 
                        
                        if (polaroidStates[1]) { 
                            const finalRightPolaroid = getFinalPolaroidCanvas(polaroidStates[1], mode); 
                            pairCtx.drawImage(finalRightPolaroid, PAIR_CANVAS_WIDTH - PAIR_POLAROID_WIDTH, 0); 
                        } else { 
                            const emptyFrameCanvas = new OffscreenCanvas(PAIR_POLAROID_WIDTH, PAIR_POLAROID_HEIGHT); 
                            drawEmptyPolaroidFrame(emptyFrameCanvas.getContext('2d')); 
                            pairCtx.drawImage(emptyFrameCanvas, PAIR_CANVAS_WIDTH - PAIR_POLAROID_WIDTH, 0); 
                        } 
                        finalBlob = await pairCanvas.convertToBlob({ type: \`image/\${saveFormat}\`, quality: saveFormat === 'jpeg' ? quality : undefined }); 
                    }

                    self.postMessage({ blob: finalBlob, filename }); 
                };`;

            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(workerBlob);

            imageUpload.addEventListener('change', e => processFiles(e.target.files));
            saveAllBtn.addEventListener('click', saveImages);
            removeAllBtn.addEventListener('click', () => { if (confirm('Are you sure you want to remove all images?')) { polaroidContainer.innerHTML = ''; updateGlobalState(); } });

            // Global frame toggles
            globalFrameToggle.addEventListener('click', e => {
                if (e.target.classList.contains('toggle-button')) {
                    const frameState = e.target.dataset.value === 'on';
                    globalFrameToggle.querySelectorAll('.toggle-button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    document.querySelectorAll('.polaroid-wrapper').forEach(wrapper => {
                        wrapper.polaroidState.isFrameless = !frameState;
                        wrapper.resetToCover();
                    });
                }
            });

            // Drag and Drop Zone
            body.addEventListener('dragover', (e) => { e.preventDefault(); body.classList.add('is-dragging'); });
            body.addEventListener('dragleave', (e) => { if (e.relatedTarget === null) body.classList.remove('is-dragging'); });
            body.addEventListener('drop', (e) => { e.preventDefault(); body.classList.remove('is-dragging'); processFiles(e.dataTransfer.files); });

            saveFormatSelect.addEventListener('change', () => {
                jpegQualityWrapper.classList.toggle('hidden', saveFormatSelect.value !== 'jpeg');
            });


            function initializeDebugMode() {
                const debugBtn = document.createElement('button');
                debugBtn.innerText = "debug";
                debugBtn.style.cssText = "position:fixed;bottom:10px;left:10px;z-index:9999;padding:4px 8px;border:1px solid #000;background:transparent;cursor:pointer;font-size:11px;";
                debugBtn.onclick = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 500; canvas.height = 500;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#' + Math.floor(Math.random() * 16777215).toString(16);
                    ctx.fillRect(0, 0, 500, 500);
                    const img = new Image();
                    img.onload = () => createPolaroid(img);
                    img.src = canvas.toDataURL();
                };
                document.body.appendChild(debugBtn);
            }

            function updateGlobalState() {
                const imageCount = document.querySelectorAll('.polaroid-wrapper').length;
                const isDisabled = imageCount === 0;

                saveAllBtn.disabled = isDisabled;
                removeAllBtn.disabled = isDisabled;
                globalFrameToggle.style.display = 'flex'; // Always visible
                saveFormatSelect.disabled = isDisabled;
                saveModeSelect.disabled = isDisabled;
                jpegQualitySelect.disabled = isDisabled;

                // Save options are always visible but disabled when no images
                document.querySelector('.save-options').classList.remove('hidden');
                container.classList.toggle('is-empty', isDisabled);
            }

            function processFiles(files) {
                if (!files || files.length === 0) return;
                Array.from(files).forEach(file => {
                    if (!file.type.startsWith('image/')) return;
                    try {
                        const reader = new FileReader();
                        reader.onload = e => { const img = new Image(); img.onload = () => createPolaroid(img); img.onerror = () => alert(`Failed to load the image "${file.name}".`); img.src = e.target.result; };
                        reader.onerror = () => alert(`Could not read the file: ${file.name}.`);
                        reader.readAsDataURL(file);
                    } catch (error) { alert(`An error occurred with file: ${file.name}.`); }
                });
            }

            function createPolaroid(img) {
                const isImageLandscape = img.width > img.height;
                const wrapper = document.createElement('div'); wrapper.className = 'polaroid-wrapper';
                const canvasContainer = document.createElement('div'); canvasContainer.className = 'canvas-container';
                const canvas = document.createElement('canvas'); canvas.className = 'polaroid-canvas';

                canvas.width = isImageLandscape ? DISPLAY_WIDTH_LANDSCAPE : DISPLAY_WIDTH_PORTRAIT;
                canvas.height = isImageLandscape ? DISPLAY_HEIGHT_LANDSCAPE : DISPLAY_HEIGHT_PORTRAIT;

                const state = { image: img, scale: 1, pos: { x: 0, y: 0 }, isLandscape: isImageLandscape, isFrameless: false, imageRotation: 0, fitScale: 1, fillScale: 1 };
                canvas.polaroidState = state;

                const controls = document.createElement('div'); controls.className = 'controls';

                // Zoom UI
                const zoomControl = document.createElement('div'); zoomControl.className = 'zoom-control';
                const zoomSlider = document.createElement('input');
                const zoomValueInput = document.createElement('input');
                const zoomInputWrapper = document.createElement('div'); zoomInputWrapper.className = 'zoom-input-wrapper';

                zoomSlider.type = 'range'; zoomSlider.className = 'zoom-slider'; zoomSlider.step = 0.01; zoomSlider.ariaLabel = "Zoom Level";
                zoomValueInput.type = 'number'; zoomValueInput.className = 'zoom-value-input'; zoomValueInput.min = 100;

                zoomControl.textContent = 'zoom: '; zoomControl.appendChild(zoomSlider);
                zoomInputWrapper.appendChild(zoomValueInput); zoomInputWrapper.insertAdjacentHTML('beforeend', `<span>%</span>`);
                zoomControl.appendChild(zoomInputWrapper);

                // Buttons
                const removeBtn = document.createElement('button'); removeBtn.className = 'button hidden'; removeBtn.textContent = 'remove'; removeBtn.title = 'Remove';

                // Rotation Toggle
                const rotationToggleGroup = document.createElement('div'); rotationToggleGroup.className = 'toggle-group';
                const rot0Btn = document.createElement('button'); rot0Btn.className = 'toggle-button active'; rot0Btn.textContent = '0째'; rot0Btn.dataset.value = '0';
                const rot90Btn = document.createElement('button'); rot90Btn.className = 'toggle-button'; rot90Btn.textContent = '90째'; rot90Btn.dataset.value = '90';
                const rot180Btn = document.createElement('button'); rot180Btn.className = 'toggle-button'; rot180Btn.textContent = '180째'; rot180Btn.dataset.value = '180';
                const rot270Btn = document.createElement('button'); rot270Btn.className = 'toggle-button'; rot270Btn.textContent = '270째'; rot270Btn.dataset.value = '270';
                rotationToggleGroup.appendChild(rot0Btn);
                rotationToggleGroup.appendChild(rot90Btn);
                rotationToggleGroup.appendChild(rot180Btn);
                rotationToggleGroup.appendChild(rot270Btn);

                // Zoom Mode Toggle
                const zoomModeToggleGroup = document.createElement('div'); zoomModeToggleGroup.className = 'toggle-group';
                const zoomContainBtn = document.createElement('button'); zoomContainBtn.className = 'toggle-button active'; zoomContainBtn.textContent = 'contain'; zoomContainBtn.dataset.value = 'contain';
                const zoomCoverBtn = document.createElement('button'); zoomCoverBtn.className = 'toggle-button'; zoomCoverBtn.textContent = 'cover'; zoomCoverBtn.dataset.value = 'cover';
                zoomModeToggleGroup.appendChild(zoomContainBtn);
                zoomModeToggleGroup.appendChild(zoomCoverBtn);

                // Frame Toggle
                const frameToggleGroup = document.createElement('div'); frameToggleGroup.className = 'toggle-group';
                const frameOnBtn = document.createElement('button'); frameOnBtn.className = 'toggle-button active'; frameOnBtn.textContent = 'frame on'; frameOnBtn.dataset.value = 'on';
                const frameOffBtn = document.createElement('button'); frameOffBtn.className = 'toggle-button'; frameOffBtn.textContent = 'frame off'; frameOffBtn.dataset.value = 'off';
                frameToggleGroup.appendChild(frameOnBtn);
                frameToggleGroup.appendChild(frameOffBtn);

                // Orientation Toggle
                const orientationToggleGroup = document.createElement('div'); orientationToggleGroup.className = 'toggle-group';
                const portraitBtn = document.createElement('button'); portraitBtn.className = 'toggle-button active'; portraitBtn.textContent = 'portrait'; portraitBtn.dataset.value = 'portrait';
                const landscapeBtn = document.createElement('button'); landscapeBtn.className = 'toggle-button'; landscapeBtn.textContent = 'landscape'; landscapeBtn.dataset.value = 'landscape';
                orientationToggleGroup.appendChild(portraitBtn);
                orientationToggleGroup.appendChild(landscapeBtn);

                // Row 1: Zoom | Contain | Cover
                const row1 = document.createElement('div'); row1.className = 'controls-row';
                row1.appendChild(zoomControl);
                row1.appendChild(zoomModeToggleGroup);

                // Row 2: Rotation
                const row2 = document.createElement('div'); row2.className = 'controls-row';
                row2.appendChild(rotationToggleGroup);

                // Row 3: Frame & Orientation
                const row3 = document.createElement('div'); row3.className = 'controls-row';
                row3.appendChild(frameToggleGroup);
                row3.appendChild(orientationToggleGroup);

                controls.appendChild(row1);
                controls.appendChild(row2);
                controls.appendChild(row3);
                canvasContainer.appendChild(canvas);
                wrapper.appendChild(canvasContainer);
                wrapper.appendChild(controls);

                polaroidContainer.appendChild(wrapper);
                updateGlobalState();

                const ctx = canvas.getContext('2d');
                const update = () => { applySmartScaling(); clampPosition(); redraw(); };
                wrapper.update = update; wrapper.polaroidState = state;

                // Exposed helper to reset zoom when frames change
                wrapper.resetToCover = () => {
                    applySmartScaling();
                    state.scale = state.fillScale;
                    state.pos = { x: 0, y: 0 };
                    clampPosition();
                    updateZoomModeButton();
                    redraw();
                };

                function updateOrientationButton() {
                    if (state.isLandscape) {
                        portraitBtn.classList.remove('active');
                        landscapeBtn.classList.add('active');
                    } else {
                        portraitBtn.classList.add('active');
                        landscapeBtn.classList.remove('active');
                    }
                }

                function updateFrameButton() {
                    if (state.isFrameless) {
                        frameOnBtn.classList.remove('active');
                        frameOffBtn.classList.add('active');
                    } else {
                        frameOnBtn.classList.add('active');
                        frameOffBtn.classList.remove('active');
                    }
                }

                function updateRotationButton() {
                    [rot0Btn, rot90Btn, rot180Btn, rot270Btn].forEach(btn => btn.classList.remove('active'));
                    const btnMap = { 0: rot0Btn, 90: rot90Btn, 180: rot180Btn, 270: rot270Btn };
                    btnMap[state.imageRotation]?.classList.add('active');
                }

                function updateZoomModeButton() {
                    const distToFit = Math.abs(state.scale - state.fitScale);
                    const distToFill = Math.abs(state.scale - state.fillScale);
                    if (distToFit <= distToFill) {
                        zoomContainBtn.classList.add('active');
                        zoomCoverBtn.classList.remove('active');
                    } else {
                        zoomContainBtn.classList.remove('active');
                        zoomCoverBtn.classList.add('active');
                    }
                }

                function updateZoomDisplay() {
                    const percentage = Math.round((state.scale / state.fitScale) * 100);
                    zoomValueInput.value = percentage;
                    zoomSlider.value = state.scale;
                }

                function applySmartScaling() {
                    const MAX_ZOOM_MULTIPLIER = 10;
                    const { innerBox } = getFrameDimensions(canvas.width, canvas.height, state.isLandscape, state.isFrameless);
                    let effectiveImgWidth = img.width;
                    let effectiveImgHeight = img.height;
                    if (state.imageRotation % 180 !== 0) { [effectiveImgWidth, effectiveImgHeight] = [effectiveImgHeight, effectiveImgWidth]; }
                    const hRatio = innerBox.width / effectiveImgWidth; const vRatio = innerBox.height / effectiveImgHeight;
                    state.fitScale = Math.min(hRatio, vRatio);
                    state.fillScale = Math.max(hRatio, vRatio);
                    // Only reset scale if currently invalid or 1
                    if (state.scale === 1) state.scale = state.fillScale;
                    zoomSlider.min = state.fitScale;
                    zoomSlider.max = state.fitScale * MAX_ZOOM_MULTIPLIER;
                    updateZoomDisplay();
                }

                function clampPosition() {
                    const { innerBox } = getFrameDimensions(canvas.width, canvas.height, state.isLandscape, state.isFrameless);
                    let effectiveImgWidth = state.image.width;
                    let effectiveImgHeight = state.image.height;
                    if (state.imageRotation % 180 !== 0) { [effectiveImgWidth, effectiveImgHeight] = [effectiveImgHeight, effectiveImgWidth]; }
                    const scaledWidth = effectiveImgWidth * state.scale; const scaledHeight = effectiveImgHeight * state.scale;
                    const overhangX = scaledWidth - innerBox.width; const maxX = Math.max(0, overhangX / 2); state.pos.x = Math.max(-maxX, Math.min(maxX, state.pos.x));
                    const overhangY = scaledHeight - innerBox.height; const maxY = Math.max(0, overhangY / 2); state.pos.y = Math.max(-maxY, Math.min(maxY, state.pos.y));
                }

                applySmartScaling();
                redraw();
                updateOrientationButton();
                updateFrameButton();
                updateRotationButton();
                updateZoomModeButton();

                function redraw() { requestAnimationFrame(() => { drawPolaroidOnCanvas(ctx, canvas.width, canvas.height, state); if (document.activeElement !== zoomSlider && document.activeElement !== zoomValueInput) { updateZoomDisplay(); } }); }

                removeBtn.onclick = () => { wrapper.style.opacity = '0'; setTimeout(() => { wrapper.remove(); updateGlobalState(); }, 200); };

                // Frame toggle handlers
                frameOnBtn.addEventListener('click', () => {
                    frameOnBtn.classList.add('active');
                    frameOffBtn.classList.remove('active');
                    state.isFrameless = false;
                    wrapper.resetToCover();
                });
                frameOffBtn.addEventListener('click', () => {
                    frameOffBtn.classList.add('active');
                    frameOnBtn.classList.remove('active');
                    state.isFrameless = true;
                    wrapper.resetToCover();
                });

                // Orientation toggle handlers
                portraitBtn.addEventListener('click', () => {
                    if (state.isLandscape) {
                        portraitBtn.classList.add('active');
                        landscapeBtn.classList.remove('active');
                        state.isLandscape = false;
                        state.pos = { x: 0, y: 0 };
                        canvas.width = DISPLAY_WIDTH_PORTRAIT;
                        canvas.height = DISPLAY_HEIGHT_PORTRAIT;
                        wrapper.resetToCover();
                    }
                });
                landscapeBtn.addEventListener('click', () => {
                    if (!state.isLandscape) {
                        landscapeBtn.classList.add('active');
                        portraitBtn.classList.remove('active');
                        state.isLandscape = true;
                        state.pos = { x: 0, y: 0 };
                        canvas.width = DISPLAY_WIDTH_LANDSCAPE;
                        canvas.height = DISPLAY_HEIGHT_LANDSCAPE;
                        wrapper.resetToCover();
                    }
                });

                // Rotation toggle handlers
                [rot0Btn, rot90Btn, rot180Btn, rot270Btn].forEach(btn => {
                    btn.addEventListener('click', () => {
                        const newRotation = parseInt(btn.dataset.value);
                        if (state.imageRotation !== newRotation) {
                            state.imageRotation = newRotation;
                            state.pos = { x: 0, y: 0 };
                            updateRotationButton();
                            update();
                        }
                    });
                });

                // Zoom mode toggle handlers
                zoomContainBtn.addEventListener('click', () => {
                    zoomContainBtn.classList.add('active');
                    zoomCoverBtn.classList.remove('active');
                    state.scale = state.fitScale;
                    state.pos = { x: 0, y: 0 };
                    clampPosition();
                    redraw();
                });
                zoomCoverBtn.addEventListener('click', () => {
                    zoomCoverBtn.classList.add('active');
                    zoomContainBtn.classList.remove('active');
                    state.scale = state.fillScale;
                    state.pos = { x: 0, y: 0 };
                    clampPosition();
                    redraw();
                });

                zoomSlider.addEventListener('input', e => { state.scale = parseFloat(e.target.value); clampPosition(); updateZoomModeButton(); redraw(); });
                zoomValueInput.addEventListener('change', e => { const percentage = parseFloat(e.target.value); if (isNaN(percentage)) return; const newScale = (percentage / 100) * state.fitScale; state.scale = Math.max(parseFloat(zoomSlider.min), Math.min(parseFloat(zoomSlider.max), newScale)); clampPosition(); updateZoomModeButton(); redraw(); });

                // Pan and Pinch Logic
                let interactionState = { dragStart: { x: 0, y: 0 }, isPinching: false, initialPinchDistance: 0, initialScale: 1 };
                function getDistance(p1, p2) { return Math.sqrt(Math.pow(p2.clientX - p1.clientX, 2) + Math.pow(p2.clientY - p1.clientY, 2)); }
                function handleMouseMove(e) { state.pos.x = e.clientX - interactionState.dragStart.x; state.pos.y = e.clientY - interactionState.dragStart.y; clampPosition(); redraw(); }

                canvas.addEventListener('mousedown', e => {
                    interactionState.dragStart.x = e.clientX - state.pos.x; interactionState.dragStart.y = e.clientY - state.pos.y;
                    canvas.addEventListener('mousemove', handleMouseMove); canvas.style.cursor = 'grabbing';
                });
                window.addEventListener('mouseup', () => { canvas.removeEventListener('mousemove', handleMouseMove); canvas.style.cursor = 'grab'; });

                canvas.addEventListener('touchstart', e => {
                    const t = e.touches;
                    if (t.length === 1) { interactionState.dragStart.x = t[0].clientX - state.pos.x; interactionState.dragStart.y = t[0].clientY - state.pos.y; }
                    else if (t.length === 2) { e.preventDefault(); interactionState.isPinching = true; interactionState.initialPinchDistance = getDistance(t[0], t[1]); interactionState.initialScale = state.scale; }
                }, { passive: false });

                canvas.addEventListener('touchmove', e => {
                    const t = e.touches;
                    if (t.length === 1 && !interactionState.isPinching) { e.preventDefault(); state.pos.x = t[0].clientX - interactionState.dragStart.x; state.pos.y = t[0].clientY - interactionState.dragStart.y; }
                    else if (t.length === 2 && interactionState.isPinching) { e.preventDefault(); const r = getDistance(t[0], t[1]) / interactionState.initialPinchDistance; state.scale = Math.max(parseFloat(zoomSlider.min), Math.min(parseFloat(zoomSlider.max), interactionState.initialScale * r)); }
                    clampPosition(); redraw();
                }, { passive: false });

                canvas.addEventListener('touchend', e => { if (e.touches.length < 2) interactionState.isPinching = false; if (e.touches.length === 1) { interactionState.dragStart.x = e.touches[0].clientX - state.pos.x; interactionState.dragStart.y = e.touches[0].clientY - state.pos.y; } });
            }

            function getFrameDimensions(canvasWidth, canvasHeight, isLandscape, isFrameless) {
                if (isFrameless) return { innerBox: { x: 0, y: 0, width: canvasWidth, height: canvasHeight } };
                const frame = isLandscape ? LANDSCAPE_FRAME : PORTRAIT_FRAME;
                let refWidth = POLAROID_EXPORT_WIDTH, refHeight = POLAROID_EXPORT_HEIGHT;
                if (isLandscape) { [refWidth, refHeight] = [refHeight, refWidth]; }
                const paddingTop = canvasHeight * (frame.top / refHeight);
                const paddingSide = canvasWidth * (frame.side / refWidth);
                const paddingBottom = canvasHeight * (frame.bottom / refHeight);
                return { innerBox: { x: Math.round(paddingSide), y: Math.round(paddingTop), width: Math.round(canvasWidth - (2 * paddingSide)), height: Math.round(canvasHeight - paddingTop - paddingBottom) } };
            }

            function drawPolaroidOnCanvas(ctx, canvasWidth, canvasHeight, state) {
                const { innerBox } = getFrameDimensions(canvasWidth, canvasHeight, state.isLandscape, state.isFrameless);
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                if (!state.isFrameless) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                }
                ctx.save();
                ctx.beginPath();
                ctx.rect(innerBox.x, innerBox.y, innerBox.width, innerBox.height);
                ctx.clip();
                const scaledWidth = state.image.width * state.scale;
                const scaledHeight = state.image.height * state.scale;
                const centerX = (innerBox.x + innerBox.width / 2) + state.pos.x;
                const centerY = (innerBox.y + innerBox.height / 2) + state.pos.y;
                ctx.save();
                ctx.translate(Math.round(centerX), Math.round(centerY));
                ctx.rotate(state.imageRotation * Math.PI / 180);
                ctx.drawImage(state.image, Math.round(-scaledWidth / 2), Math.round(-scaledHeight / 2), Math.round(scaledWidth), Math.round(scaledHeight));
                ctx.restore();
                ctx.restore();
            }

            function generateTimestampFilename(fileNumber, totalFiles) {
                const now = new Date();
                const YYYY = now.getFullYear(); const MM = String(now.getMonth() + 1).padStart(2, '0'); const DD = String(now.getDate()).padStart(2, '0');
                const hh = String(now.getHours()).padStart(2, '0'); const mm = String(now.getMinutes()).padStart(2, '0'); const ss = String(now.getSeconds()).padStart(2, '0');
                const paddedNumber = String(fileNumber).padStart(String(totalFiles).length > 0 ? String(totalFiles).length : 1, '0');
                return `${YYYY}-${MM}-${DD}_${hh}-${mm}-${ss}_${paddedNumber}`;
            }

            function updateSaveButtonProgress(current, total) {
                saveAllBtn.textContent = `saving ${current}/${total}`;
            }

            async function saveImages() {
                if (typeof OffscreenCanvas === 'undefined') {
                    alert("Your browser does not support the technology required to export these images (OffscreenCanvas). Please try using Chrome, Edge, or a newer version of Safari.");
                    return;
                }

                const canvases = Array.from(document.querySelectorAll('.polaroid-canvas'));
                if (canvases.length === 0) return;
                saveAllBtn.disabled = true;

                const mode = saveModeSelect.value; // 'pair' or 'individual'
                const jobQueue = [];

                if (mode === 'individual') {
                    for (let i = 0; i < canvases.length; i++) {
                        jobQueue.push({ leftIndex: i, rightIndex: null });
                    }
                } else {
                    for (let i = 0; i < canvases.length; i += 2) {
                        jobQueue.push({ leftIndex: i, rightIndex: i + 1 });
                    }
                }

                const numFiles = jobQueue.length;
                let filesProcessed = 0;

                const worker = new Worker(workerUrl);

                let polaroidDirHandle;
                try {
                    if ('showDirectoryPicker' in window) {
                        polaroidDirHandle = await window.showDirectoryPicker();
                        polaroidDirHandle = await polaroidDirHandle.getDirectoryHandle('polaroid', { create: true });
                    }
                } catch (error) { console.log('File System Access API skipped or failed.'); }

                const processNextJobInQueue = async () => {
                    if (jobQueue.length === 0) {
                        saveAllBtn.textContent = 'save';
                        updateGlobalState();
                        worker.terminate();
                        if (polaroidDirHandle) alert(`Saved to "polaroid" folder!`);
                        return;
                    }
                    const job = jobQueue.shift();
                    const fileIndex = filesProcessed + 1;
                    const transferList = [];
                    const polaroidStates = [];

                    const leftCanvas = canvases[job.leftIndex];
                    if (leftCanvas) {
                        const bmp = await createImageBitmap(leftCanvas.polaroidState.image);
                        transferList.push(bmp);
                        polaroidStates.push({ ...leftCanvas.polaroidState, image: bmp });
                    }

                    if (mode === 'pair') {
                        const rightCanvas = canvases[job.rightIndex];
                        if (rightCanvas) {
                            const bmp = await createImageBitmap(rightCanvas.polaroidState.image);
                            transferList.push(bmp);
                            polaroidStates.push({ ...rightCanvas.polaroidState, image: bmp });
                        }
                    }

                    const saveFormat = saveFormatSelect.value;
                    const quality = parseFloat(jpegQualitySelect.value);
                    const fileExtension = saveFormat === 'jpeg' ? '.jpeg' : '.png';
                    const filename = generateTimestampFilename(fileIndex, numFiles) + fileExtension;

                    worker.postMessage({ polaroidStates, saveFormat, quality, filename, mode }, transferList);
                };

                worker.onmessage = async (e) => {
                    const { blob, filename } = e.data;
                    try {
                        if (polaroidDirHandle) {
                            const fileHandle = await polaroidDirHandle.getFileHandle(filename, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                        } else {
                            const link = document.createElement('a');
                            const url = URL.createObjectURL(blob);
                            link.href = url;
                            link.download = filename;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }
                    } catch (error) { console.error(error); }

                    filesProcessed++;
                    updateSaveButtonProgress(filesProcessed, numFiles);
                    processNextJobInQueue();
                };

                updateSaveButtonProgress(0, numFiles);
                processNextJobInQueue();
            }
            updateGlobalState();
        });
    </script>
</body>

</html>